---
layout: post
---

<h2>{{ page.title }}</h2>
<p class='meta'>{{ page.date | date_to_string }} - NanJing</p>
----------

{% highlight cpp %}
// ConsoleApplication4.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <iostream>
#include <cstdlib>
#include <ctime>
#include<vector>
#include<limits.h>
#include<string>
#include <algorithm>
#include<sstream>

using namespace std;

struct ListNode{
	int data;
	ListNode* next;
};

template < typename T >



int binFind(const T* list, const T& target, int startAt, int endAt)
{
	/*
	if (startAt > endAt)
		return -1;
	int mid = startAt + (endAt - startAt) / 2;
	if (list[mid] == target)
		return mid;
	else if (list[mid] > target)
		return binFind(list, target, startAt, mid - 1);
	else
		return binFind(list, target, mid + 1, endAt);
	*/
	int mid = 0;
	while (startAt <= endAt)
	{
		mid = startAt + (endAt - startAt) / 2;
		if (list[mid] == target)
			return mid;
		else if (list[mid] > target)
			endAt = mid - 1;
		else
			startAt = mid + 1;
	}
}

void Qsort(int a[], int low, int high)
{
	if (low >= high)
	{
		return;
	}
	int first = low;
	int last = high;
	int key = a[first];/*用字表的第一个记录作为枢轴*/

	while (first < last)
	{
		while (first < last && a[last] >= key)
		{
			--last;
		}

		a[first] = a[last];/*将比第一个小的移到低端*/

		while (first < last && a[first] <= key)
		{
			++first;
		}

		a[last] = a[first];
		/*将比第一个大的移到高端*/
	}
	a[first] = key;/*枢轴记录到位*/
	Qsort(a, low, first - 1);
	Qsort(a, first + 1, high);
}

bool cmp(const string it1, const string it2)
{
	return (it1) < (it2);
}

void removeBlank(char str[])
{
	int length = strlen(str);
	bool last = false;//blank
	int start = 0, end=0;
	int cur = 0;
	for (int i = 0; i < length; i++)
	{
		if (*(str + i) == ' ')
		{
			if (last)
			{
				end = i;
				for (int j = start; j < end; j++,cur++)
				{
					str[cur] = str[j];
				}
				str[cur] = ' ';
				cur++;
			}
			last = false;
		}
		else
		{
			if (!last)
			{
				start = i;
			}
			last = true;
			if (i + 1 == length)
			{
				end = i + 1;
				for (int j = start; j < end; j++, cur++)
				{
					str[cur] = str[j];
				}
				str[cur] = ' ';
				cur++;
			}
		}
	}
	if (cur>0)
		str[cur-1] = '\0';
	else
		str[cur] = '\0';
}

int compu(int a, int b)
{
	if (a == 0 || b == 0)
		return 0;
	int n = 0, result=0;
	int bb = b;
	int base = 1;
	while (b)
	{
		int c = b*a;
		c += n;
		n = c / 10;
		result += (c%10)*base;
		base *= 10;
		n = c / 10;
		b--;
	}
	return result;
}

void dirtSort(vector<string>& strvector)
{
	sort(strvector.begin(), strvector.end(),cmp);
}

void swap(int *p, int start, int end)
{
	int temp = p[start];
	p[start] = p[end];
	p[end] = temp;
}

void printRes(int *p, int n)
{
	for (int i = 0; i <= n; i++)
	{
		cout << p[i];
	}
	cout << endl;
}

void quanpailie(int *p,int start,int end)
{
	if (start == end)
		printRes(p, end);
	for (int i = start; i <= end; i++)
	{
		swap(p, start, i);
		quanpailie(p, start + 1, end);
		swap(p, start, i);
	}
}

void insertToStackBottom(vector<int>& testStack, int bottom)
{
	if (testStack.empty()) {
		testStack.push_back(bottom);
		return;
	}
	int top = testStack.back();
	testStack.pop_back(); 
	insertToStackBottom(testStack, bottom);
	testStack.push_back(top);
}

void reverseStack(vector<int>& v, int length)
{
	if (length > 0)
	{
		int temp = v.back();
		v.pop_back();
		reverseStack(v, --length);
		insertToStackBottom(v, temp);
	}
}

bool chkPalindrome(ListNode* li)
{
	if (!li)
		return true;
	ListNode* a = li;
	ListNode* b = li;
	ListNode* c = li;
	int length=0;
	vector<int> vec;
	while (c)
	{
		vec.push_back(b->data);
		length++;
		c = c->next;
		if (!c)
		{
			break;
		}
		length++;
		b = b->next;
		c = c->next;
	}
	cout << b->data << " middle"<<length << endl;
	vec.pop_back();
	if (length & 1)//qi
	{
		b = b->next;
	}
	while (b)
	{
		if (b->data != vec.back())
			return false;
		b = b->next;
		vec.pop_back();
	}
	return true;
}

bool chkPalindrome2(ListNode* li)
{
	if (!li)
		return true;
	ListNode* a = li;
	ListNode* b = li;
	ListNode* c = li;
	int length = 0;
	vector<int> vec;
	while (c)
	{
		vec.push_back(b->data);
		length++;
		c = c->next;
		if (!c)
		{
			break;
		}
		length++;
		b = b->next;
		c = c->next;
	}
	cout << b->data << " middle" << length << endl;
	ListNode *tail = b;
	ListNode *temp = b->next;
	b->next = NULL;
	while (temp)
	{
		ListNode *c = temp->next;
		temp->next = tail;
		tail = temp;
		temp = c;
	}
	while (li != tail&&tail!=NULL)
	{
		if (li->data != tail->data)
			return false;
		tail = tail->next;
		li = li->next;
	}
	return true;
}

int function(int arr[],int n, int t, int c)
{
	int count = 0;
	for (int i = 0; i < n - c; i++)
	{
		int temp = arr[i];
		for (int j = 1; j < c; j++)
			temp += arr[i+c];
		if (temp <= t)
			count++;
	}
	return count;
}

int myfunction(vector<int>& arr, int n)
{
	if (n < 2)
		return 0;
	if (n == 2)
		return arr[0] + arr[1];
	int monkey = 0;
	for (int i = 1; i < n-1; i++)
	{
		int max = arr[0] + arr[1];
		int index;
		for (int j = 1; j < n - i; j++)
		{
			int temp = arr[j] + arr[j + 1];
			if (temp < max)
			{
				max = temp;
				index = j;
			}
		}
		vector<int>::iterator iter = arr.begin();
		arr.erase(iter + index, iter + index+2);
		arr.erase(iter + index);
		arr.insert(iter + index, max);
		monkey += max;
	}
	return monkey;
}

char *combine(unsigned long date, char* p)
{
	stringstream s;
	s << date;
	string sa;
	s >> sa;
	int n1 = sa.length(),n2=strlen(p) + 2;
	char *p2 = (char*)malloc(sizeof(char)*(n1+n2));
	int i = 0,j=0;
	while (i<n1)
	{
		p2[i] = sa[i];
		i++;
	}
	p2[i++] = '_';
	while (j<n2)
	{
		p2[i] = p[j];
		i++;
		j++;
	}
	p2[i] = '\0';
	return p2;
}

int grade()
{
	int N, M;
	cin >> N >> M;
	vector<int> res;
	int *arr = new int[M];
	for (int i = 0; i < N; i++)
	{
		cin >> arr[i];
	}
	while (M--)
	{
		char oper;
		int first, second;
		cin >> oper >> first >> second;
		if (oper == 'U')
		{
			arr[first - 1] = second;
		}
		else
		{
			int max = arr[first-1];
			for (; first <= second-1; first++)
			{
				if (arr[first] > max)
					max = arr[first];
			}
			res.push_back(max);
		}
		
	}
	for (int i = 0; i < res.size(); i++)
	{
		cout << res[i] << endl;
	
	}
	return 0;
}

void log()
{
	string str;
	int line;

	while (cin >> str >> line)
	{

		cout << str << " " << line << endl;
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	//二分查找
	int arr[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int find = binFind(arr, 8, 0, 8);
	cout << "Found at: " << find << endl;


	//快速排序
	int arr1[] = { 2, 4, 1, 3, 9, 8, 6, 5, 7 };
	//	qsort(arr1, 9,sizeof(arr1[0]),cmp);
	//	sort(arr1, arr1+9);
	Qsort(arr1, 0, 8);
	for (int i = 0; i < 9; i++)
		cout << arr1[i] << " ";
	cout << endl;


	//除空格
	char p[] = "    las  lsal lsal las      ";
	cout << p << endl;
	removeBlank(p);
	cout << p << "!" << endl;


	//字典序
	/*
	vector<string> strvec;
	string str;
	cin >> str;
	while(str!="-0")
	{
	strvec.push_back(str);
	cin >> str;
	}
	for (vector<string>::iterator iter = strvec.begin(); iter != strvec.end();iter++)
	cout<<*iter<<endl;
	dirtSort(strvec);
	for (vector<string>::iterator iter = strvec.begin(); iter != strvec.end(); iter++)
	cout << *iter << endl;

	//3+33+333+3333
	int a, b;
	cin >> a >> b;
	cout << a << " " << b << endl;
	while (a!=0||b!=0)
	{
	cout <<compu(a,b) << endl;
	cin >> a >> b;
	}
	*/

	//全排列
	int arr11[] = { 1, 2, 3, 4 };
	quanpailie(arr11, 0, sizeof(arr11) / sizeof(arr11[0]) - 1);


	//递归逆序栈
	int a[] = { 1, 2, 3 };
	vector<int> v(a, a + 3);
	for (vector<int>::iterator iter = v.begin(); iter != v.end(); iter++)
	{
		cout << *iter << " ";
	}
	cout << endl;
	reverseStack(v, 3);
	for (vector<int>::iterator iter = v.begin(); iter != v.end(); iter++)
	{
		cout << *iter << " ";
	}
	cout << endl;

	//链表回文
	int abb[] = { 1, 2,3,4,6,3, 2, 1 };
	ListNode *head = new ListNode();
	head->data = abb[0];
	ListNode *h = head;
	ListNode *p1 = head;
	for (int i = 1; i < sizeof(abb) / sizeof(abb[0]); i++)
	{
		ListNode *temp = new ListNode();
		temp->data = abb[i];
		p1->next = temp;
		p1 = temp;
	}
	p1->next = NULL;
	cout << "list" << endl;
	while (head)
	{
		cout << head->data << endl;
		head = head->next;
	}
	cout << chkPalindrome2(h) << endl;
	int y = 10;
	int c = 3;
	printf("%d\n",c=y/c);
	/*
	int n;
	cin >> n;
	int max = 0;
	int count = 0;
	while (n--)
	{
		int a, b;
		cin >> a >> b;
		count = max + (b - a);
		if (count > max)
			max += count;
	}
	cout << max;
	*/
	char *str11 = "cvte";
	cout<<combine(20150915,str11)<<endl;

//	grade();

	log();
	return 0;
} 
{% endhighlight %}

----------
