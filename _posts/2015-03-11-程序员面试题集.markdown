---
layout: post
---

<h2>{{ page.title }}</h2>
<p class='meta'>{{ page.date | date_to_string }} - NanJing</p>

---


### 【程序员之路】分享：程序员面试——电话面试问答40个问题 ###

[http://mp.weixin.qq.com/s?__biz=MzA3MTIxNzkyNg==&mid=203560984&idx=1&sn=756f01f2c5b55e8c30bcaba47120cffb&scene=4#wechat_redirect](http://mp.weixin.qq.com/s?__biz=MzA3MTIxNzkyNg==&mid=203560984&idx=1&sn=756f01f2c5b55e8c30bcaba47120cffb&scene=4#wechat_redirect)

### 小知识点 ###

linux命令：man；touch；cat and less；sort and grep ；cut ；sed；tar ；find ；diff ；uniq ；chmod ；grep工具【该工具用于匹配】 ；sed 工具 【该工具用于行间的内容操作，如增删改，查找替换】 ；awk 工具【该工具用于处理有字段规则的行内内容，并支持格式化输出】

字符串匹配：KMP算法、BM算法、正则表达式

主键（保持数据完整）、外键（与其它表建立联系）：约束作用（插入禁止空）；级联（主键记录删除、外键记录也删除）

int to string:
stringstream ss;
ss << timeCount << i;
reutrn ss.str();

类型安全CPP:new 返回确切对象类型；malloc返回的是(void *)， 需显示转化，(chat *)行，但(int *)有问题

数据库范式：
一范式：需要保持每一列的原子性。例：电话号码：86-010-11111111
如果要符合一范式，那么需要把电话号码拆分为国家号码、区号、电话号码进行存储，达到每一列不能够再拆分。符合原子性的标准即为一范式。
二范式：首先必须符合一范式。另外需要满足，每一个表必须有主键，除主键外其他的列必须和主键相关，不能只与主键的某一个部分相关。例如一个表有一个联合主键，而部分数据是与联合主键相关而不与主键相关，那么这时需要把表拆开，使得每一列都与主键相关。
三范式：首先必须符合二范式，另外需要满足，每一个非主键列必须直接依赖主键，而不能存在传递依赖。
一原子二相关三依赖

泊松分布：
（1）顾客购买水果罐头是小概率事件。
（2）购买水果罐头的顾客是独立的，不会互相影响。
（3）顾客购买水果罐头的概率是稳定的。

1、::是c++域操作符，C中不能编译通过。  
2、避免float、double用“==”或“！=”与数字比较，应设法转化为“>=”或“<=”的形式（精度范围内允许的误差）。表达式中存在有符号数和无符号数时，自动转为无符号类型。数在内存中以补码存在。  
3、extern "C"：以C的编译习惯编译文件，解决名字匹配问题。例如重载函数C++中可能是_foo_int_int和_foo_int_float，而C不支持重载，只是_foo。  
4、stdlib.h中的atexit(void(*) (void))函数用来注册程序正常终止时要调用的函数，并且调用顺序与注册顺序相反。  
5、宏中使用#将宏参数变为字符串，##把两个宏参数连接起来。#define STR(s) #s，则STR(string)则打印string。#define CON(a,b) (int)(a##e##b)，则CON(2,3)表示2000。  
6、static全局变量只初始化一次，防止在其他文件中被引用，局部变量初始化一次，下一次依据上一次的值，static函数内存中只一份。类的static属于类不属于类的实例，可在所有类的实例间共享。类名::静态方法()。  
7、inline放在函数定义处方能发挥作用。  
8、变量声明与定义区别：是否分配了内存。int a是定义式声明，分配内存；extern int a是非定义式声明，不分配内存  
9、vector<int> ivec;
vector<int>::const_iterator citer1 = ivec.begin();
const vector<int>::iterator citer2 = ivec.begin();
*citer1 = 1; //error
*citer2 = 1; //right
++citer1; //right
++citer2; //error  
10、const成员函数内不能改变成员变量

海量数据处理：http://blog.csdn.net/v_july_v/article/details/7382693 [所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。 那解决办法呢?针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树，针对空间，无非就一个办法：大而化小，分而治之（hash映射），你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛。]
无非就是分而治之/hash映射 + hash统计 + 堆/快速/归并排序，说白了，就是先映射（一次可装进内存则跳过），而后统计，最后排序：

堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）

STL:序列式容器(vector/list/deque/stack/queue/heap)；关联式容器。关联式容器又分为set(集合)和map(映射表)两大类，也就是说，set/map/multiset/multimap都内含一个RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtable

这两个函数是差不多的，但由于优化方案不同，通常NOT Exists要比NOT IN要快，因为NOT EXISTS可以使用结合算法二NOT IN就不行了，而EXISTS则不如IN快，因为这时候IN可能更多的使用结合算法。

Select * from tableA Where exists(Select * From tableB Where tableB.ID=tableA.ID)

这句相当于：Select * from tableA Where id in (Select ID From tableB)

对于表tableA的每一条数据，都执行Select * From tableB Where tableB.ID=tableA.ID的存在性判断，如果表tableB中存在表tableA当前行相同的ID，则Exists为真，该行显示，否则不显示。

IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况
In确定给定的值是否与子查询或列表中的值相匹配
Exists指定一个子查询，检测行的存在

临界存储区是一段代码，同一时间只允许一个线程访问执行，通过信号量或互斥锁实现线程安全。

死锁：互斥条件、请求和保持条件、不剥夺条件、环路等待

共享锁（读锁）、排他锁（写锁）。

尾递归：如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。。尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n, sum) = f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。是一种变形迭代。  

&a是一个指向数组的指针（行指针），a的步长就是数组的长度。也就是说执行a+1时，a要跨过n个整型数据的长度，输出*ptr就会发现越界了，是一个随机值，那么ptr-1的值就是数组的最后一个值了。

++，--这两种操作符要求作用于左值，所以i++合法，(-i)++不合法

三元表达式“?:”问号后面的两个操作数必须为同一类型

SOLID:
单一责任原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口分离原则

网站静态化处理:静态网页的资源基本是不会发生变化的。减少http请求（合并精简css、js文件、图片预加载）、浏览器缓存(http协议之cache-control)、脚本放页面底部、传输数据压缩、CDN。但是动态网页不易缓存，这是应该拆分网页了，把网页做一个动静分离，让静态的部分（菜单、页首和页尾）当做不变的静态资源进行处理，动态的内容还是动态处理，然后在合适的地方将动静内容合并在一起。

### 算法分类 ###
排序：选择、快速、堆、希尔 |前述不稳定| 归并、插入、冒泡、基数、位图、多路归并  
搜索：顺序、二分、散列、二分搜索树、索引  
字符串、向量和矩阵、随机、数值算法

### 代码调优 ###
空间换时间：修改数据结构、存储预先算好的结果、高速缓存、避免不必要求值  
时间换空间：堆积（稀疏数组、压缩算法） 
循环：代码移出循环、合并测试条件（哨兵使用多一位来存目标值以检测退出循环时idx位置）、展开循环、删除肤质、消除无条件分支、循环合并  
逻辑：重新排序测试条件    
过程：打破函数层次（内联函数）、递归函数转换（迭代、尾递归）  
表达式：编译时初始化（变量初始化）、消除公共字表达式

---