---
layout: post
---

<h2>{{ page.title }}</h2>
<p class='meta'>{{ page.date | date_to_string }} - NanJing,  powered by 阮一峰</p>

----------

![jsj](http://he110jean.opendrive.com/files/MzdfMzU1MF9aVjlVTw/book.jpg)

## C++ Prime ##

###数据类型###
- while (std::cin >> value)读取未知个数输入  
- 要让地址为 736425 的字节具有意义，必须要知道存储在该地址的值的
- 类型。一旦知道了该地址的值的类型，就知道了表示该类型的值需要多
- 少位和如何解释这些位。   
- bool 类型表示真值 true 和 false。可以将算术类型的任何值赋给 bool对象。0 值算术类型代表 false，任何非 0 的值都代表 true。 
- 其中long 和 int 范围是[-2^31,2^31)，即-2147483648~2147483647。而unsigned范围是[0,2^32)，即0~4294967295。也就是说，常规的32位整数只能够处理40亿以下的数。long long 与 unsigned long long：[-2^63, 2^63)与[0,2^64)  
-  左值（发音为 ell-value）：左值可以出现在赋值语句的左边或右边。右值（发音为 are-value）：右值只能出现在赋值的右边，不能出现在赋值语句的左边。 变量是左值，数字是右值。++i是直接给i变量加1，然后返回i本身，因为i是变量，所以可以被赋值，因此是左值表达式
i++现产生一个临时变量，记录i的值，而后给i加1，接着返回临时变量，然后临时变量不存在了，所以，不能再被赋值，因此是右值表达式
-  C++ 是一门静态类型语言，在编译时会作类型检查。在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。
-  C++ 程序员经常随意地使用术语对象。一般而言，对象就是内存中具有类型的区域。说得更具体一些，计算左值表达式就会产生对象。
-  全局作用域、局部（函数和类）、语句（for）
-  非 const 变量默认为 extern。要使 const 变量能够在其他的文件中访问，必须地指定它为 extern（在所有地方）。 
-  非 const 引用只能绑定到与该引用同类型的对象。const 引用则可以绑定到不同但相关的类型的对象或绑定到右值。  
{% highlight cpp %}
	int &refVal3 = 10; // error: initializer must be an object  
	int i = 42;
	// legal for const references only  
	const int &r = 42;  
	const int &r2 = r + i;  
	double dval = 3.14;
	const int &ri = dval; 
{% endhighlight %}
- 默认地，第一个枚举成员赋值为 0，后面的每个枚举成员赋的值比前面的大1。 枚举成员值可以是不唯一的。    
{% highlight cpp %}
	// point2d is 2, point2w is 3, point3d is 3, point3w is 4  
	enum Points { point2d = 2, point2w,	point3d = 3, point3w }; 
{% endhighlight %}
- 使用 class 还是 struct 关键字来定义类，仅仅影响默认的初始访问级别（前者private，后者public）。 
- 当设计头文件时，记住定义和声明的区别是很重要的。定义只可以出现一次，而声明则可以出现多次（第 2.3.5 节）。下列语句是一些定义，所以不应该放在头文件里：  
{% highlight cpp %}
	extern int ival = 10; // initializer, so it's a definition  
	double fica_rate; // no extern, so it's a definition 
{% endhighlight %}
对于头文件不应该含有定义这一规则，有三个例外。头文件可以定义类、值在编译时就已知道的 const 对象和 inline 函数（第 7.6 节介绍 inline 函数）。这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。

###标准库（类模板）###
- cin>>string空格为界，getline（）以换行符为界。   
{% highlight cpp %}  
	int main()
	 {
		 string line;
		 // read line at time until end-of-file
		 while (getline(cin, line))
		 cout << line << endl;
		 return 0;
	 }
	//string支持下标操作
	string str("some string");
	for (string::size_type ix = 0; ix != str.size(); ++ix)
		cout << str[ix] << endl; 
{% endhighlight %}
- vector：push_back、pop_back、erase  
{% highlight cpp %}  
    for(vector<int>::iterator it=arr.begin(); it!=arr.end(); )
    {
        if(* it == 8)
        {
            it = arr.erase(it);
        }
        else
        {
            ++it;
        }
    }

	//注意上面不能写成
    /*
        for(vector<int>::iterator it=arr.begin(); it!=arr.end(); it ++)
        {
            if(* it == 8)
            {
                arr.erase(it);     //在erase后，it失效，并不是指向vector的下一个元素，it成了一个“野指针”。
            }
        }
	*/
{% endhighlight %}  
- 迭代器是一种检查容器内元素并遍历元素的数据类型。 
{% highlight cpp %}  
	for (vector<string>::const_iterator iter = text.begin();
	 iter != text.end(); ++ iter)
		*iter = " "; // error: *iter is const

	vector<int> nums(10); // nums is nonconst
	const vector<int>::iterator cit = nums.begin();
	*cit = 1; // ok: cit can change its underlying element
	++cit; // error: can't change the value of cit 
{% endhighlight %} 
- bitset：
{% highlight cpp %} 
	bitset<32> bitvec; // 32 bits, all zero
	// bitvec1 is smaller than the initializer
	bitset<16> bitvec1(0xffff); // bits 0 ... 15 are set to 1
	// bitvec2 same size as initializer
	bitset<32> bitvec2(0xffff); // bits 0 ... 15 are set to 1; 16 ... 31 are 0
	// on a 32-bit machine, bits 0 to 31 initialized from 0xffff
	bitset<128> bitvec3(0xffff); // bits 32 through 127 initialized to zero 
	string str("1111111000000011001101");
	bitset<32> bitvec5(str, 5, 4); // 4 bits starting at str[5], 1100
	bitset<32> bitvec6(str, str.size() - 4); // use last 4 characters 
{% endhighlight %} 
string 对象和 bitsets 对象之间是反向转化的：string 对象的最右边字符（即下标最大的那个字符）用来初始化 bitset 对象的低阶位（即下标为 0 的位）。当用 string 对象初始化 bitset 对象时，记住这一差别很重要。

###数组和指针###
- C++ 语言提供了两种类似于 vector 和迭代器类型的低级复合类型——数组和指针。
数组维度需常量：此常量表达式只能包含整型字面值常量、枚举常量或者用常量表达式初始化的整型 const 对象。非 const 变量以及要到运行阶段才知道其值的 const
变量都不能用于定义数组的维数。 
- 如果必须分开定义指针和其所指向的对象，则将指针初始化为NULL(0)。因为编译 器可检测出0 值的指针，程序可判断该指针并未指向一个对象。 
- C++ 提供了一种特殊的指针类型 void*，它可以保存任何类型对象的地址.
- 用 typedef 简化指向多维数组的指针，比如typedef int int_array[4];如果去掉前面的typedef那么定义的是一个叫做int_array的含有4个元素的数组。前面加上typedef以后，int_array就变成了含有4个元素的数组类型的替代名。以后要有int_array ia;这句话我们就知道它等同于int ia[4];

###表达式###
###语句###
###函数###
- 当函数执行完毕时，将释放分配给局部对象的存储空间。此时，对局部对象
的引用就会指向不确定的内存。考虑下面的程序：
{% highlight cpp %} 
 // Disaster: Function returns a reference to a local object
 const string &manip(const string& s)
 {
 string ret = s;
 // transform ret in some way
 return ret; // Wrong: Returning reference to a local object!
 }
{% endhighlight %} 
这个函数会在运行时出错，因为它返回了局部对象的引用。当函数执行完毕，字符串 ret 占用的储存空间被释放，函数返回值指向了对于这个程序来说不再有效的内存空间。确保返回引用安全的一个好方法是：请自问，这个引用指向哪个在此之前存在的对象？ 

###序列容器###

###关联容器###

###泛型算法###

###类和数据抽象###
- 类用来定义自己的抽象数据类型。定义了一个新的类型和一个新的作用域。
- const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声明和定义中，若只出现在其中一处，就会出现一个编译时错误。 
- 数据抽象：一种依赖于接口和实现分离的编程技术。 封装是一项低层次的元素组合起来的形成新的、高层次技术。函数是一种封装的形式。
- 定义对象时，将为其分配存储空间，但（一般而言）定义类型时不进行存储分配
- 尽管在成员函数内部显式引用 this 通常是不必要的，但有一种情况下必须这样做：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。最常见的情况是在这样的函数中使用 this：该函数返回对调用该函数的对象的引用。
{% highlight cpp %} 
	Screen& Screen::move(index r, index c)
	{	
		index row = r * width; // row location
		cursor = row + c;
		return *this;
	}
{% endhighlight %} 
- 如果将 display 定义为 const 成员，就可以在非 const 对象上调用 display，但不能将对 display 的调用嵌入到一个长表达式中(myScreen.display().set('*');)。问题在于这个表达式是在由 display 返回的对象上运行 set。该对象是const，因为 display 将其对象作为 const 返回。我们不能在 const 对象上调用 set。 为了解决这个问题，我们必须定义两个 display 操作：一个是 const，另一个不是 const。
- 可变数据成员（mutable data member）永远都不能为 const，甚至当它是const 对象的成员时也如此。因此，const 成员函数可以改变 mutable 成员。要将数据成员声明为可变的，必须将关键字 mutable 放在成员声明之前：

----------
