---
layout: post
---

<h2>{{ page.title }}</h2>
<p class='meta'>{{ page.date | date_to_string }} - NanJing</p>
----------

### LeetCode - 215 ###

{% highlight java %}

	package kthLargestElementInAanArray;
	
	import java.util.Comparator;
	import java.util.PriorityQueue;
	import java.util.Queue;
	
	/*Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
	
	For example,
	Given [3,2,1,5,6,4] and k = 2, return 5.
	
	Note: 
	You may assume k is always valid, 1 ≤ k ≤ array's length.
	*/
	
	public class Solution {
		
		public static Comparator<Integer> myCompare = new Comparator<Integer>(){  
			   
	        @Override  
	        public int compare(Integer c1, Integer c2) {  
	            return (int) (c1 - c2);
	        }  
	    };
		
	    public int findKthLargest(int[] nums, int k) {
	    	Queue<Integer> heap = new PriorityQueue<Integer>(k, myCompare);
	    	for(int num:nums)
	    	{
	    		if(heap.size()==k)
	    		{
	    			if(heap.peek()<num)
	    			{
	    				heap.poll();
	    				heap.add(num);
	    			}
	    		}
	    		else
	    		{
	    			heap.add(num);
	    		}
	    	}
	    	return heap.peek();
	    }
	}

{% endhighlight %}

### LeetCode - 415 ###

{% highlight java %}

	package addString;
	
	/*Given two non-negative numbers num1 and num2 represented as string, return the sum of num1 and num2.
	
	Note:
	
	The length of both num1 and num2 is < 5100.
	Both num1 and num2 contains only digits 0-9.
	Both num1 and num2 does not contain any leading zero.
	You must not use any built-in BigInteger library or convert the inputs to integer directly.
	*/
	public class Solution {
		public String addStrings(String num1, String num2) {
			StringBuffer sum = new StringBuffer();
			char[] numArray1 = num1.toCharArray();
			char[] numArray2 = num2.toCharArray();
			int length1 = num1.length();
			int length2 = num2.length();
			int maxlength = length1 > length2 ? length1 : length2;
			int overf = 0;
			while (maxlength > 0) {
				int t = overf;
				int sub1 = length1<1?0:numArray1[length1 - 1] - '0';
				int sub2 = length2<1?0:numArray2[length2 - 1] - '0';;
				t += sub1 + sub2;
				overf = t/10;
				t %= 10;
				length1--;
				length2--;
				sum.append((char) (t + '0'));
				maxlength--;
			}
			if (overf == 1) {
				sum.append('1');
			}
			return sum.reverse().toString();
		}
	}


{% endhighlight %}

### LeetCode - 415 ###

{% highlight java %}

	package queueReconstructionByHeight;
	
	import java.util.ArrayList;
	import java.util.Comparator;
	import java.util.List;
	import java.util.PriorityQueue;
	import java.util.Queue;
	
	public class Solution {
	
		public static Comparator<int[]> myCompare = new Comparator<int[]>() {
	
			@Override
			public int compare(int[] c1, int[] c2) {
				return c1[0]==c2[0]?c1[1]-c2[1]:c2[0]-c1[0];
			}
		};
	
		public int[][] reconstructQueue(int[][] people) {
	
			Queue<int[]> heap = new PriorityQueue<int[]>(people.length, myCompare);
	//		Arrays.sort(people, myCompare);
			
			for(int[] p: people)
			{
				heap.add(p);
			}
			
			List<int[]> rest = new ArrayList<int[]>();
			
			while(!heap.isEmpty())
			{
				int[] t = heap.poll();
				rest.add(t[1], t);
			}
	
			return rest.toArray(new int[people.length][]);
		}
	}



{% endhighlight %}

----------
